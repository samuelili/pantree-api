// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: ingredients.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createIngredient = `-- name: CreateIngredient :one
INSERT INTO
  Ingredients (
    creator_id,
    name,
    unit,
    storage_loc,
    ingredient_type,
    image_path
  )
VALUES
  (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
  )
RETURNING
  id, creator_id, name, unit, storage_loc, ingredient_type, image_path, last_modified
`

type CreateIngredientParams struct {
	CreatorID      *uuid.UUID  `json:"creatorId"`
	Name           string      `json:"name"`
	Unit           UnitType    `json:"unit"`
	StorageLoc     LocType     `json:"storageLoc"`
	IngredientType GrocType    `json:"ingredientType"`
	ImagePath      pgtype.Text `json:"imagePath"`
}

// WHERE
//
//	name = sqlc.arg('name');
//
// date created is current date
func (q *Queries) CreateIngredient(ctx context.Context, arg CreateIngredientParams) (Ingredient, error) {
	row := q.db.QueryRow(ctx, createIngredient,
		arg.CreatorID,
		arg.Name,
		arg.Unit,
		arg.StorageLoc,
		arg.IngredientType,
		arg.ImagePath,
	)
	var i Ingredient
	err := row.Scan(
		&i.ID,
		&i.CreatorID,
		&i.Name,
		&i.Unit,
		&i.StorageLoc,
		&i.IngredientType,
		&i.ImagePath,
		&i.LastModified,
	)
	return i, err
}

const deleteIngredient = `-- name: DeleteIngredient :exec
DELETE FROM Ingredients
WHERE
  id = $1
`

func (q *Queries) DeleteIngredient(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteIngredient, id)
	return err
}

const getIngredients = `-- name: GetIngredients :many
SELECT
  id, creator_id, name, unit, storage_loc, ingredient_type, image_path, last_modified
FROM
  Ingredients
`

func (q *Queries) GetIngredients(ctx context.Context) ([]Ingredient, error) {
	rows, err := q.db.Query(ctx, getIngredients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ingredient
	for rows.Next() {
		var i Ingredient
		if err := rows.Scan(
			&i.ID,
			&i.CreatorID,
			&i.Name,
			&i.Unit,
			&i.StorageLoc,
			&i.IngredientType,
			&i.ImagePath,
			&i.LastModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIngredientsByIds = `-- name: GetIngredientsByIds :many
SELECT
  id, creator_id, name, unit, storage_loc, ingredient_type, image_path, last_modified
FROM
  Ingredients
WHERE
  id = ANY($1::uuid[])
`

func (q *Queries) GetIngredientsByIds(ctx context.Context, ids []uuid.UUID) ([]Ingredient, error) {
	rows, err := q.db.Query(ctx, getIngredientsByIds, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ingredient
	for rows.Next() {
		var i Ingredient
		if err := rows.Scan(
			&i.ID,
			&i.CreatorID,
			&i.Name,
			&i.Unit,
			&i.StorageLoc,
			&i.IngredientType,
			&i.ImagePath,
			&i.LastModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchIngredients = `-- name: SearchIngredients :many
SELECT
  id, creator_id, name, unit, storage_loc, ingredient_type, image_path, last_modified
FROM
  Ingredients
WHERE
  name ILIKE '%' || $1 || '%'
`

func (q *Queries) SearchIngredients(ctx context.Context, name pgtype.Text) ([]Ingredient, error) {
	rows, err := q.db.Query(ctx, searchIngredients, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ingredient
	for rows.Next() {
		var i Ingredient
		if err := rows.Scan(
			&i.ID,
			&i.CreatorID,
			&i.Name,
			&i.Unit,
			&i.StorageLoc,
			&i.IngredientType,
			&i.ImagePath,
			&i.LastModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
