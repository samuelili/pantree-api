// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

type GrocType string

const (
	GrocTypeMeatSeafood GrocType = "meat/seafood"
	GrocTypeProduce     GrocType = "produce"
	GrocTypeDairyEggs   GrocType = "dairy/eggs"
	GrocTypePrepared    GrocType = "prepared"
	GrocTypeEssentials  GrocType = "essentials"
	GrocTypeBakery      GrocType = "bakery"
	GrocTypeSnacks      GrocType = "snacks"
	GrocTypeFrozen      GrocType = "frozen"
	GrocTypeBeverages   GrocType = "beverages"
	GrocTypeDesserts    GrocType = "desserts"
	GrocTypeAlcohol     GrocType = "alcohol"
)

func (e *GrocType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GrocType(s)
	case string:
		*e = GrocType(s)
	default:
		return fmt.Errorf("unsupported scan type for GrocType: %T", src)
	}
	return nil
}

type NullGrocType struct {
	GrocType GrocType `json:"grocType"`
	Valid    bool     `json:"valid"` // Valid is true if GrocType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGrocType) Scan(value interface{}) error {
	if value == nil {
		ns.GrocType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GrocType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGrocType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GrocType), nil
}

type LocType string

const (
	LocTypePantry  LocType = "pantry"
	LocTypeFridge  LocType = "fridge"
	LocTypeFreezer LocType = "freezer"
)

func (e *LocType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LocType(s)
	case string:
		*e = LocType(s)
	default:
		return fmt.Errorf("unsupported scan type for LocType: %T", src)
	}
	return nil
}

type NullLocType struct {
	LocType LocType `json:"locType"`
	Valid   bool    `json:"valid"` // Valid is true if LocType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLocType) Scan(value interface{}) error {
	if value == nil {
		ns.LocType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LocType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLocType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LocType), nil
}

type MeasureType string

const (
	MeasureTypeMetric   MeasureType = "metric"
	MeasureTypeImperial MeasureType = "imperial"
)

func (e *MeasureType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MeasureType(s)
	case string:
		*e = MeasureType(s)
	default:
		return fmt.Errorf("unsupported scan type for MeasureType: %T", src)
	}
	return nil
}

type NullMeasureType struct {
	MeasureType MeasureType `json:"measureType"`
	Valid       bool        `json:"valid"` // Valid is true if MeasureType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMeasureType) Scan(value interface{}) error {
	if value == nil {
		ns.MeasureType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MeasureType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMeasureType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MeasureType), nil
}

type UnitType string

const (
	UnitTypeCountQtr UnitType = "count_qtr"
	UnitTypeVolumeMl UnitType = "volume_ml"
	UnitTypeMassG    UnitType = "mass_g"
)

func (e *UnitType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UnitType(s)
	case string:
		*e = UnitType(s)
	default:
		return fmt.Errorf("unsupported scan type for UnitType: %T", src)
	}
	return nil
}

type NullUnitType struct {
	UnitType UnitType `json:"unitType"`
	Valid    bool     `json:"valid"` // Valid is true if UnitType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUnitType) Scan(value interface{}) error {
	if value == nil {
		ns.UnitType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UnitType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUnitType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UnitType), nil
}

type Favorite struct {
	UserID   uuid.UUID `json:"userId"`
	RecipeID uuid.UUID `json:"recipeId"`
}

type Ingredient struct {
	ID             uuid.UUID   `json:"id"`
	CreatorID      *uuid.UUID  `json:"creatorId"`
	Name           string      `json:"name"`
	Unit           UnitType    `json:"unit"`
	StorageLoc     LocType     `json:"storageLoc"`
	IngredientType GrocType    `json:"ingredientType"`
	ImagePath      pgtype.Text `json:"imagePath"`
}

type Recipe struct {
	ID          uuid.UUID       `json:"id"`
	CreatorID   *uuid.UUID      `json:"creatorId"`
	DateCreated pgtype.Date     `json:"dateCreated"`
	Name        string          `json:"name"`
	Description pgtype.Text     `json:"description"`
	Steps       []string        `json:"steps"`
	Allergens   []string        `json:"allergens"`
	CookingTime decimal.Decimal `json:"cookingTime"`
	ServingSize decimal.Decimal `json:"servingSize"`
	ImagePath   pgtype.Text     `json:"imagePath"`
}

type Recipeingredient struct {
	RecipeID          uuid.UUID       `json:"recipeId"`
	IngredientID      uuid.UUID       `json:"ingredientId"`
	Quantity          decimal.Decimal `json:"quantity"`
	AuthorUnitType    UnitType        `json:"authorUnitType"`
	AuthorMeasureType MeasureType     `json:"authorMeasureType"`
}

type Recipeingredientsview struct {
	Name           string          `json:"name"`
	Unit           UnitType        `json:"unit"`
	StorageLoc     LocType         `json:"storageLoc"`
	IngredientType GrocType        `json:"ingredientType"`
	Quantity       decimal.Decimal `json:"quantity"`
	RecipeID       uuid.UUID       `json:"recipeId"`
}

type User struct {
	ID           uuid.UUID   `json:"id"`
	Email        string      `json:"email"`
	Name         string      `json:"name"`
	DateJoined   pgtype.Date `json:"dateJoined"`
	PrefMeasure  MeasureType `json:"prefMeasure"`
	LastModified time.Time   `json:"lastModified"`
}

type Useritementry struct {
	ID             uuid.UUID           `json:"id"`
	UserID         *uuid.UUID          `json:"userId"`
	IngredientID   *uuid.UUID          `json:"ingredientId"`
	Quantity       decimal.Decimal     `json:"quantity"`
	Price          decimal.NullDecimal `json:"price"`
	ExpirationDate **time.Time         `json:"expirationDate"`
	LastModified   time.Time           `json:"lastModified"`
	DeletedAt      **time.Time         `json:"deletedAt"`
}

type Userpantryview struct {
	UserID                uuid.UUID       `json:"userId"`
	UserEmail             string          `json:"userEmail"`
	UserMeasurementSystem MeasureType     `json:"userMeasurementSystem"`
	IngredientName        string          `json:"ingredientName"`
	Quantity              decimal.Decimal `json:"quantity"`
	ExpirationDate        **time.Time     `json:"expirationDate"`
	Unit                  UnitType        `json:"unit"`
	StorageLoc            LocType         `json:"storageLoc"`
	IngredientType        GrocType        `json:"ingredientType"`
	LastModified          time.Time       `json:"lastModified"`
}
