// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const addFavorite = `-- name: AddFavorite :exec
INSERT INTO
  Favorites (user_id, recipe_id)
VALUES
  ($1, $2)
RETURNING
  user_id, recipe_id
`

type AddFavoriteParams struct {
	UserID   uuid.UUID `json:"userId"`
	RecipeID uuid.UUID `json:"recipeId"`
}

func (q *Queries) AddFavorite(ctx context.Context, arg AddFavoriteParams) error {
	_, err := q.db.Exec(ctx, addFavorite, arg.UserID, arg.RecipeID)
	return err
}

const createIngredient = `-- name: CreateIngredient :one
INSERT INTO
  Ingredients (
    creator_id,
    name,
    unit,
    storage_loc,
    ingredient_type,
    image_path
  )
VALUES
  (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
  )
RETURNING
  id, creator_id, name, unit, storage_loc, ingredient_type, image_path
`

type CreateIngredientParams struct {
	CreatorID      *uuid.UUID  `json:"creatorId"`
	Name           string      `json:"name"`
	Unit           UnitType    `json:"unit"`
	StorageLoc     LocType     `json:"storageLoc"`
	IngredientType GrocType    `json:"ingredientType"`
	ImagePath      pgtype.Text `json:"imagePath"`
}

// WHERE
//
//	name = sqlc.arg('name');
//
// date created is current date
func (q *Queries) CreateIngredient(ctx context.Context, arg CreateIngredientParams) (Ingredient, error) {
	row := q.db.QueryRow(ctx, createIngredient,
		arg.CreatorID,
		arg.Name,
		arg.Unit,
		arg.StorageLoc,
		arg.IngredientType,
		arg.ImagePath,
	)
	var i Ingredient
	err := row.Scan(
		&i.ID,
		&i.CreatorID,
		&i.Name,
		&i.Unit,
		&i.StorageLoc,
		&i.IngredientType,
		&i.ImagePath,
	)
	return i, err
}

const createRecipe = `-- name: CreateRecipe :one
INSERT INTO
  Recipes (
    creator_id,
    date_created,
    name,
    description,
    steps,
    allergens,
    cooking_time,
    serving_size,
    image_path
  )
VALUES
  (
    $1,
    CURRENT_DATE,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
  )
RETURNING
  id, creator_id, date_created, name, description, steps, allergens, cooking_time, serving_size, image_path
`

type CreateRecipeParams struct {
	CreatorID   *uuid.UUID      `json:"creatorId"`
	Name        string          `json:"name"`
	Description pgtype.Text     `json:"description"`
	Steps       []string        `json:"steps"`
	Allergens   []string        `json:"allergens"`
	CookingTime decimal.Decimal `json:"cookingTime"`
	ServingSize decimal.Decimal `json:"servingSize"`
	ImagePath   pgtype.Text     `json:"imagePath"`
}

// date created is current date
func (q *Queries) CreateRecipe(ctx context.Context, arg CreateRecipeParams) (Recipe, error) {
	row := q.db.QueryRow(ctx, createRecipe,
		arg.CreatorID,
		arg.Name,
		arg.Description,
		arg.Steps,
		arg.Allergens,
		arg.CookingTime,
		arg.ServingSize,
		arg.ImagePath,
	)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.CreatorID,
		&i.DateCreated,
		&i.Name,
		&i.Description,
		&i.Steps,
		&i.Allergens,
		&i.CookingTime,
		&i.ServingSize,
		&i.ImagePath,
	)
	return i, err
}

const createRecipeIngredient = `-- name: CreateRecipeIngredient :one
INSERT INTO
  RecipeIngredients (
    recipe_id,
    ingredient_id,
    quantity,
    author_unit_type,
    author_measure_type
  )
VALUES
  (
    $1,
    $2,
    $3,
    $4,
    $5
  )
RETURNING
  recipe_id, ingredient_id, quantity, author_unit_type, author_measure_type
`

type CreateRecipeIngredientParams struct {
	RecipeID          uuid.UUID       `json:"recipeId"`
	IngredientID      uuid.UUID       `json:"ingredientId"`
	Quantity          decimal.Decimal `json:"quantity"`
	AuthorUnitType    UnitType        `json:"authorUnitType"`
	AuthorMeasureType MeasureType     `json:"authorMeasureType"`
}

func (q *Queries) CreateRecipeIngredient(ctx context.Context, arg CreateRecipeIngredientParams) (Recipeingredient, error) {
	row := q.db.QueryRow(ctx, createRecipeIngredient,
		arg.RecipeID,
		arg.IngredientID,
		arg.Quantity,
		arg.AuthorUnitType,
		arg.AuthorMeasureType,
	)
	var i Recipeingredient
	err := row.Scan(
		&i.RecipeID,
		&i.IngredientID,
		&i.Quantity,
		&i.AuthorUnitType,
		&i.AuthorMeasureType,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO
  Users (email, name, date_joined, pref_measure)
VALUES
  (
    $1,
    $2,
    CURRENT_DATE,
    $3
  )
RETURNING
  id, email, name, date_joined, pref_measure, last_modified
`

type CreateUserParams struct {
	Email       string      `json:"email"`
	Name        string      `json:"name"`
	PrefMeasure MeasureType `json:"prefMeasure"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Email, arg.Name, arg.PrefMeasure)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.DateJoined,
		&i.PrefMeasure,
		&i.LastModified,
	)
	return i, err
}

const createUserItem = `-- name: CreateUserItem :one
INSERT INTO
  UserItems (
    user_id,
    ingredient_id,
    quantity,
    price,
    expiration_date
  )
VALUES
  (
    $1,
    $2,
    $3,
    $4,
    $5
  )
RETURNING
  id, user_id, ingredient_id, quantity, price, expiration_date, last_modified, deleted_at
`

type CreateUserItemParams struct {
	UserID         *uuid.UUID          `json:"userId"`
	IngredientID   *uuid.UUID          `json:"ingredientId"`
	Quantity       decimal.Decimal     `json:"quantity"`
	Price          decimal.NullDecimal `json:"price"`
	ExpirationDate **time.Time         `json:"expirationDate"`
}

func (q *Queries) CreateUserItem(ctx context.Context, arg CreateUserItemParams) (Useritem, error) {
	row := q.db.QueryRow(ctx, createUserItem,
		arg.UserID,
		arg.IngredientID,
		arg.Quantity,
		arg.Price,
		arg.ExpirationDate,
	)
	var i Useritem
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.IngredientID,
		&i.Quantity,
		&i.Price,
		&i.ExpirationDate,
		&i.LastModified,
		&i.DeletedAt,
	)
	return i, err
}

const deleteUserItem = `-- name: DeleteUserItem :exec
UPDATE
  UserItems
SET
  deleted_at = CURRENT_TIMESTAMP,
  last_modified = CURRENT_TIMESTAMP
WHERE
  id = $1
`

func (q *Queries) DeleteUserItem(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserItem, id)
	return err
}

const getFavorites = `-- name: GetFavorites :many
SELECT
  recipe_id
FROM
  Favorites
WHERE
  user_id = $1
`

func (q *Queries) GetFavorites(ctx context.Context, userID uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getFavorites, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var recipe_id uuid.UUID
		if err := rows.Scan(&recipe_id); err != nil {
			return nil, err
		}
		items = append(items, recipe_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIngredients = `-- name: GetIngredients :many
SELECT
  id, creator_id, name, unit, storage_loc, ingredient_type, image_path
FROM
  Ingredients
`

func (q *Queries) GetIngredients(ctx context.Context) ([]Ingredient, error) {
	rows, err := q.db.Query(ctx, getIngredients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ingredient
	for rows.Next() {
		var i Ingredient
		if err := rows.Scan(
			&i.ID,
			&i.CreatorID,
			&i.Name,
			&i.Unit,
			&i.StorageLoc,
			&i.IngredientType,
			&i.ImagePath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecipe = `-- name: GetRecipe :one
SELECT
  id, creator_id, date_created, name, description, steps, allergens, cooking_time, serving_size, image_path
FROM
  Recipes
WHERE
  id = $1
LIMIT
  1
`

func (q *Queries) GetRecipe(ctx context.Context, id uuid.UUID) (Recipe, error) {
	row := q.db.QueryRow(ctx, getRecipe, id)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.CreatorID,
		&i.DateCreated,
		&i.Name,
		&i.Description,
		&i.Steps,
		&i.Allergens,
		&i.CookingTime,
		&i.ServingSize,
		&i.ImagePath,
	)
	return i, err
}

const getRecipeIngredients = `-- name: GetRecipeIngredients :many
SELECT
  name,
  unit,
  storage_loc,
  ingredient_type,
  quantity,
  recipe_id
FROM
  RecipeIngredientsView
WHERE
  recipe_id = $1
`

// $1: recipe_id
func (q *Queries) GetRecipeIngredients(ctx context.Context, recipeID uuid.UUID) ([]Recipeingredientsview, error) {
	rows, err := q.db.Query(ctx, getRecipeIngredients, recipeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recipeingredientsview
	for rows.Next() {
		var i Recipeingredientsview
		if err := rows.Scan(
			&i.Name,
			&i.Unit,
			&i.StorageLoc,
			&i.IngredientType,
			&i.Quantity,
			&i.RecipeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT
  id, email, name, date_joined, pref_measure, last_modified
FROM
  Users u
WHERE
  (
    $1::uuid IS NOT NULL
    AND u.id = $1::uuid
  )
  OR (
    $2::text IS NOT NULL
    AND u.email = $2::text
  )
`

type GetUserParams struct {
	ID    *uuid.UUID  `json:"id"`
	Email pgtype.Text `json:"email"`
}

// select by either id or email
func (q *Queries) GetUser(ctx context.Context, arg GetUserParams) (User, error) {
	row := q.db.QueryRow(ctx, getUser, arg.ID, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.DateJoined,
		&i.PrefMeasure,
		&i.LastModified,
	)
	return i, err
}

const getUserItems = `-- name: GetUserItems :many
SELECT
  id, user_id, ingredient_id, quantity, price, expiration_date, last_modified, deleted_at
FROM
  UserItems
WHERE
  user_id = $1
`

// returns user items in the rawest form
func (q *Queries) GetUserItems(ctx context.Context, userID *uuid.UUID) ([]Useritem, error) {
	rows, err := q.db.Query(ctx, getUserItems, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Useritem
	for rows.Next() {
		var i Useritem
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.IngredientID,
			&i.Quantity,
			&i.Price,
			&i.ExpirationDate,
			&i.LastModified,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserItemsSinceTime = `-- name: GetUserItemsSinceTime :many
SELECT
  id, user_id, ingredient_id, quantity, price, expiration_date, last_modified, deleted_at
FROM
  UserItems
WHERE
  user_id = $1
  AND last_modified > $2
`

type GetUserItemsSinceTimeParams struct {
	UserID       *uuid.UUID `json:"userId"`
	LastModified time.Time  `json:"lastModified"`
}

func (q *Queries) GetUserItemsSinceTime(ctx context.Context, arg GetUserItemsSinceTimeParams) ([]Useritem, error) {
	rows, err := q.db.Query(ctx, getUserItemsSinceTime, arg.UserID, arg.LastModified)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Useritem
	for rows.Next() {
		var i Useritem
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.IngredientID,
			&i.Quantity,
			&i.Price,
			&i.ExpirationDate,
			&i.LastModified,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPantry = `-- name: GetUserPantry :many
SELECT
  user_measurement_system,
  ingredient_name,
  quantity,
  expiration_date,
  unit,
  storage_loc,
  ingredient_type,
  last_modified
FROM
  UserPantryView
WHERE
  (
    $1::uuid IS NOT NULL
    AND user_id = $1::uuid
  )
  OR (
    $2::text IS NOT NULL
    AND user_email = $2::text
  )
`

type GetUserPantryParams struct {
	UserID *uuid.UUID  `json:"userId"`
	Email  pgtype.Text `json:"email"`
}

type GetUserPantryRow struct {
	UserMeasurementSystem MeasureType     `json:"userMeasurementSystem"`
	IngredientName        string          `json:"ingredientName"`
	Quantity              decimal.Decimal `json:"quantity"`
	ExpirationDate        **time.Time     `json:"expirationDate"`
	Unit                  UnitType        `json:"unit"`
	StorageLoc            LocType         `json:"storageLoc"`
	IngredientType        GrocType        `json:"ingredientType"`
	LastModified          time.Time       `json:"lastModified"`
}

// select by either id or email
func (q *Queries) GetUserPantry(ctx context.Context, arg GetUserPantryParams) ([]GetUserPantryRow, error) {
	rows, err := q.db.Query(ctx, getUserPantry, arg.UserID, arg.Email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserPantryRow
	for rows.Next() {
		var i GetUserPantryRow
		if err := rows.Scan(
			&i.UserMeasurementSystem,
			&i.IngredientName,
			&i.Quantity,
			&i.ExpirationDate,
			&i.Unit,
			&i.StorageLoc,
			&i.IngredientType,
			&i.LastModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecipes = `-- name: ListRecipes :many
SELECT
  id, creator_id, date_created, name, description, steps, allergens, cooking_time, serving_size, image_path
FROM
  Recipes
`

func (q *Queries) ListRecipes(ctx context.Context) ([]Recipe, error) {
	rows, err := q.db.Query(ctx, listRecipes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recipe
	for rows.Next() {
		var i Recipe
		if err := rows.Scan(
			&i.ID,
			&i.CreatorID,
			&i.DateCreated,
			&i.Name,
			&i.Description,
			&i.Steps,
			&i.Allergens,
			&i.CookingTime,
			&i.ServingSize,
			&i.ImagePath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeFavorite = `-- name: RemoveFavorite :exec
DELETE FROM Favorites
WHERE
  user_id = $1
  AND recipe_id = $2
`

type RemoveFavoriteParams struct {
	UserID   uuid.UUID `json:"userId"`
	RecipeID uuid.UUID `json:"recipeId"`
}

func (q *Queries) RemoveFavorite(ctx context.Context, arg RemoveFavoriteParams) error {
	_, err := q.db.Exec(ctx, removeFavorite, arg.UserID, arg.RecipeID)
	return err
}

const updateRecipe = `-- name: UpdateRecipe :exec
UPDATE Recipes
SET
  creator_id = COALESCE($1, creator_id),
  date_created = COALESCE($2, date_created),
  name = COALESCE($3, name),
  description = COALESCE($4, description),
  steps = COALESCE($5, steps),
  allergens = COALESCE($6, allergens),
  cooking_time = COALESCE($7, cooking_time),
  serving_size = COALESCE($8, serving_size),
  image_path = COALESCE($9, image_path)
WHERE
  id = $10
RETURNING
  id, creator_id, date_created, name, description, steps, allergens, cooking_time, serving_size, image_path
`

type UpdateRecipeParams struct {
	CreatorID   *uuid.UUID          `json:"creatorId"`
	DateCreated pgtype.Date         `json:"dateCreated"`
	Name        pgtype.Text         `json:"name"`
	Description pgtype.Text         `json:"description"`
	Steps       []string            `json:"steps"`
	Allergens   []string            `json:"allergens"`
	CookingTime decimal.NullDecimal `json:"cookingTime"`
	ServingSize decimal.NullDecimal `json:"servingSize"`
	ImagePath   pgtype.Text         `json:"imagePath"`
	ID          uuid.UUID           `json:"id"`
}

// all fields are optional except for id
func (q *Queries) UpdateRecipe(ctx context.Context, arg UpdateRecipeParams) error {
	_, err := q.db.Exec(ctx, updateRecipe,
		arg.CreatorID,
		arg.DateCreated,
		arg.Name,
		arg.Description,
		arg.Steps,
		arg.Allergens,
		arg.CookingTime,
		arg.ServingSize,
		arg.ImagePath,
		arg.ID,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE Users
SET
  email = COALESCE($1, email),
  name = COALESCE($2, name),
  date_joined = COALESCE($3, date_joined),
  pref_measure = COALESCE(
    $4::measure_type,
    pref_measure
  )
WHERE
  id = $5
RETURNING
  id, email, name, date_joined, pref_measure, last_modified
`

type UpdateUserParams struct {
	Email       pgtype.Text     `json:"email"`
	Name        pgtype.Text     `json:"name"`
	DateJoined  pgtype.Date     `json:"dateJoined"`
	PrefMeasure NullMeasureType `json:"prefMeasure"`
	ID          uuid.UUID       `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.Email,
		arg.Name,
		arg.DateJoined,
		arg.PrefMeasure,
		arg.ID,
	)
	return err
}

const updateUserItem = `-- name: UpdateUserItem :one
UPDATE
  UserItems
SET
  quantity = $1,
  price = $2,
  expiration_date = $3,
  last_modified = CURRENT_TIMESTAMP
WHERE
  id = $4
RETURNING
  id, user_id, ingredient_id, quantity, price, expiration_date, last_modified, deleted_at
`

type UpdateUserItemParams struct {
	Quantity       decimal.Decimal     `json:"quantity"`
	Price          decimal.NullDecimal `json:"price"`
	ExpirationDate **time.Time         `json:"expirationDate"`
	ID             uuid.UUID           `json:"id"`
}

func (q *Queries) UpdateUserItem(ctx context.Context, arg UpdateUserItemParams) (Useritem, error) {
	row := q.db.QueryRow(ctx, updateUserItem,
		arg.Quantity,
		arg.Price,
		arg.ExpirationDate,
		arg.ID,
	)
	var i Useritem
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.IngredientID,
		&i.Quantity,
		&i.Price,
		&i.ExpirationDate,
		&i.LastModified,
		&i.DeletedAt,
	)
	return i, err
}

const upsertUserItem = `-- name: UpsertUserItem :one
INSERT INTO UserItems (
  id,
  user_id,
  ingredient_id,
  quantity,
  price,
  expiration_date,
  last_modified,
  deleted_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8
)
ON CONFLICT (id) DO UPDATE
SET
  user_id = EXCLUDED.user_id,
  ingredient_id = EXCLUDED.ingredient_id,
  quantity = EXCLUDED.quantity,
  price = EXCLUDED.price,
  expiration_date = EXCLUDED.expiration_date,
  last_modified = EXCLUDED.last_modified,
  deleted_at = EXCLUDED.deleted_at
WHERE
  EXCLUDED.last_modified > UserItems.last_modified
RETURNING id, user_id, ingredient_id, quantity, price, expiration_date, last_modified, deleted_at
`

type UpsertUserItemParams struct {
	ID             uuid.UUID           `json:"id"`
	UserID         *uuid.UUID          `json:"userId"`
	IngredientID   *uuid.UUID          `json:"ingredientId"`
	Quantity       decimal.Decimal     `json:"quantity"`
	Price          decimal.NullDecimal `json:"price"`
	ExpirationDate **time.Time         `json:"expirationDate"`
	LastModified   time.Time           `json:"lastModified"`
	DeletedAt      **time.Time         `json:"deletedAt"`
}

func (q *Queries) UpsertUserItem(ctx context.Context, arg UpsertUserItemParams) (Useritem, error) {
	row := q.db.QueryRow(ctx, upsertUserItem,
		arg.ID,
		arg.UserID,
		arg.IngredientID,
		arg.Quantity,
		arg.Price,
		arg.ExpirationDate,
		arg.LastModified,
		arg.DeletedAt,
	)
	var i Useritem
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.IngredientID,
		&i.Quantity,
		&i.Price,
		&i.ExpirationDate,
		&i.LastModified,
		&i.DeletedAt,
	)
	return i, err
}
