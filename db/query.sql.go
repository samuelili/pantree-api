// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addFavorite = `-- name: AddFavorite :exec
INSERT INTO Favorites (
  user_id, recipe_id
) VALUES (
  $1,
  $2
)
RETURNING user_id, recipe_id
`

type AddFavoriteParams struct {
	UserID   pgtype.UUID
	RecipeID pgtype.UUID
}

func (q *Queries) AddFavorite(ctx context.Context, arg AddFavoriteParams) error {
	_, err := q.db.Exec(ctx, addFavorite, arg.UserID, arg.RecipeID)
	return err
}

const createIngredient = `-- name: CreateIngredient :one
INSERT INTO Ingredients (
  name, unit, storage_loc, ingredient_type, image_path
) VALUES (
  $1, 
  $2, 
  $3, 
  $4, 
  $5
)
RETURNING id, name, unit, storage_loc, ingredient_type, image_path
`

type CreateIngredientParams struct {
	Name           string
	Unit           UnitType
	StorageLoc     LocType
	IngredientType GrocType
	ImagePath      pgtype.Text
}

// date created is current date
func (q *Queries) CreateIngredient(ctx context.Context, arg CreateIngredientParams) (Ingredient, error) {
	row := q.db.QueryRow(ctx, createIngredient,
		arg.Name,
		arg.Unit,
		arg.StorageLoc,
		arg.IngredientType,
		arg.ImagePath,
	)
	var i Ingredient
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Unit,
		&i.StorageLoc,
		&i.IngredientType,
		&i.ImagePath,
	)
	return i, err
}

const createRecipe = `-- name: CreateRecipe :one
INSERT INTO Recipes (
  creator_id, date_created, name, description, steps, 
  allergens, cooking_time, serving_size, image_path  
) VALUES (
  $1, 
  CURRENT_DATE, 
  $2, 
  $3, 
  $4,
  $5,
  $6,
  $7,
  $8
)
RETURNING id, creator_id, date_created, name, description, steps, allergens, cooking_time, serving_size, image_path
`

type CreateRecipeParams struct {
	CreatorID   pgtype.UUID
	Name        string
	Description pgtype.Text
	Steps       []string
	Allergens   []string
	CookingTime pgtype.Numeric
	ServingSize pgtype.Numeric
	ImagePath   pgtype.Text
}

// date created is current date
func (q *Queries) CreateRecipe(ctx context.Context, arg CreateRecipeParams) (Recipe, error) {
	row := q.db.QueryRow(ctx, createRecipe,
		arg.CreatorID,
		arg.Name,
		arg.Description,
		arg.Steps,
		arg.Allergens,
		arg.CookingTime,
		arg.ServingSize,
		arg.ImagePath,
	)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.CreatorID,
		&i.DateCreated,
		&i.Name,
		&i.Description,
		&i.Steps,
		&i.Allergens,
		&i.CookingTime,
		&i.ServingSize,
		&i.ImagePath,
	)
	return i, err
}

const createRecipeIngredient = `-- name: CreateRecipeIngredient :one
INSERT INTO RecipeIngredients (
  recipe_id, ingredient_id, quantity, author_unit_type, author_measure_type
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5
)
RETURNING recipe_id, ingredient_id, quantity, author_unit_type, author_measure_type
`

type CreateRecipeIngredientParams struct {
	RecipeID          pgtype.UUID
	IngredientID      pgtype.UUID
	Quantity          pgtype.Numeric
	AuthorUnitType    UnitType
	AuthorMeasureType MeasureType
}

func (q *Queries) CreateRecipeIngredient(ctx context.Context, arg CreateRecipeIngredientParams) (Recipeingredient, error) {
	row := q.db.QueryRow(ctx, createRecipeIngredient,
		arg.RecipeID,
		arg.IngredientID,
		arg.Quantity,
		arg.AuthorUnitType,
		arg.AuthorMeasureType,
	)
	var i Recipeingredient
	err := row.Scan(
		&i.RecipeID,
		&i.IngredientID,
		&i.Quantity,
		&i.AuthorUnitType,
		&i.AuthorMeasureType,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO Users (
  email, name, date_joined, pref_measure
) VALUES (
  $1,
  $2,
  CURRENT_DATE,
  $3
)
RETURNING id, email, name, date_joined, pref_measure
`

type CreateUserParams struct {
	Email       string
	Name        string
	PrefMeasure MeasureType
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Email, arg.Name, arg.PrefMeasure)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.DateJoined,
		&i.PrefMeasure,
	)
	return i, err
}

const getFavorites = `-- name: GetFavorites :many
SELECT
  recipe_id
FROM
  Favorites
WHERE
  user_id = $1
`

func (q *Queries) GetFavorites(ctx context.Context, userID pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getFavorites, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var recipe_id pgtype.UUID
		if err := rows.Scan(&recipe_id); err != nil {
			return nil, err
		}
		items = append(items, recipe_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIngredients = `-- name: GetIngredients :many
SELECT id, name, unit, storage_loc, ingredient_type, image_path FROM Ingredients
`

func (q *Queries) GetIngredients(ctx context.Context) ([]Ingredient, error) {
	rows, err := q.db.Query(ctx, getIngredients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ingredient
	for rows.Next() {
		var i Ingredient
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Unit,
			&i.StorageLoc,
			&i.IngredientType,
			&i.ImagePath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecipe = `-- name: GetRecipe :one
SELECT id, creator_id, date_created, name, description, steps, allergens, cooking_time, serving_size, image_path FROM Recipes
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRecipe(ctx context.Context, id pgtype.UUID) (Recipe, error) {
	row := q.db.QueryRow(ctx, getRecipe, id)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.CreatorID,
		&i.DateCreated,
		&i.Name,
		&i.Description,
		&i.Steps,
		&i.Allergens,
		&i.CookingTime,
		&i.ServingSize,
		&i.ImagePath,
	)
	return i, err
}

const getRecipeIngredients = `-- name: GetRecipeIngredients :many
SELECT 
  name, 
  unit, 
  storage_loc, 
  ingredient_type,
  quantity,
  recipe_id
FROM
  RecipeIngredientsView
WHERE
  recipe_id = $1
`

// $1: recipe_id
func (q *Queries) GetRecipeIngredients(ctx context.Context, recipeID pgtype.UUID) ([]Recipeingredientsview, error) {
	rows, err := q.db.Query(ctx, getRecipeIngredients, recipeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recipeingredientsview
	for rows.Next() {
		var i Recipeingredientsview
		if err := rows.Scan(
			&i.Name,
			&i.Unit,
			&i.StorageLoc,
			&i.IngredientType,
			&i.Quantity,
			&i.RecipeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT 
  id, email, name, date_joined, pref_measure 
FROM 
  Users u
WHERE
  ($1::uuid IS NOT NULL AND u.id = $1::uuid) 
  OR ($2::text IS NOT NULL AND u.email = $2::text)
`

type GetUserParams struct {
	ID    pgtype.UUID
	Email pgtype.Text
}

// select by either id or email
func (q *Queries) GetUser(ctx context.Context, arg GetUserParams) (User, error) {
	row := q.db.QueryRow(ctx, getUser, arg.ID, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.DateJoined,
		&i.PrefMeasure,
	)
	return i, err
}

const getUserPantry = `-- name: GetUserPantry :many
SELECT
  user_measurement_system,
  ingredient_name,
  quantity,
  expiration_date,
  unit, 
  storage_loc,
  ingredient_type
FROM
  UserPantryView
WHERE
  ($1::uuid IS NOT NULL AND id = $1::uuid) 
  OR ($2::text IS NOT NULL AND email = $2::text)
`

type GetUserPantryParams struct {
	UserID pgtype.UUID
	Email  pgtype.Text
}

// select by either id or email
func (q *Queries) GetUserPantry(ctx context.Context, arg GetUserPantryParams) ([]Userpantryview, error) {
	rows, err := q.db.Query(ctx, getUserPantry, arg.UserID, arg.Email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Userpantryview
	for rows.Next() {
		var i Userpantryview
		if err := rows.Scan(
			&i.UserMeasurementSystem,
			&i.IngredientName,
			&i.Quantity,
			&i.ExpirationDate,
			&i.Unit,
			&i.StorageLoc,
			&i.IngredientType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecipes = `-- name: ListRecipes :many
SELECT id, creator_id, date_created, name, description, steps, allergens, cooking_time, serving_size, image_path FROM Recipes
`

func (q *Queries) ListRecipes(ctx context.Context) ([]Recipe, error) {
	rows, err := q.db.Query(ctx, listRecipes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recipe
	for rows.Next() {
		var i Recipe
		if err := rows.Scan(
			&i.ID,
			&i.CreatorID,
			&i.DateCreated,
			&i.Name,
			&i.Description,
			&i.Steps,
			&i.Allergens,
			&i.CookingTime,
			&i.ServingSize,
			&i.ImagePath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeFavorite = `-- name: RemoveFavorite :exec
DELETE FROM 
  Favorites 
WHERE 
  user_id = $1 AND recipe_id = $2
`

type RemoveFavoriteParams struct {
	UserID   pgtype.UUID
	RecipeID pgtype.UUID
}

func (q *Queries) RemoveFavorite(ctx context.Context, arg RemoveFavoriteParams) error {
	_, err := q.db.Exec(ctx, removeFavorite, arg.UserID, arg.RecipeID)
	return err
}

const updateRecipe = `-- name: UpdateRecipe :exec
UPDATE Recipes
SET
  creator_id = COALESCE($1, creator_id),
  date_created = COALESCE($2, date_created),
  name = COALESCE($3, name),
  description = COALESCE($4, description),
  steps = COALESCE($5, steps),
  allergens = COALESCE($6, allergens),
  cooking_time = COALESCE($7, cooking_time),
  serving_size = COALESCE($8, serving_size),
  image_path = COALESCE($9, image_path)
WHERE 
  id = $10
RETURNING id, creator_id, date_created, name, description, steps, allergens, cooking_time, serving_size, image_path
`

type UpdateRecipeParams struct {
	CreatorID   pgtype.UUID
	DateCreated pgtype.Date
	Name        pgtype.Text
	Description pgtype.Text
	Steps       []string
	Allergens   []string
	CookingTime pgtype.Numeric
	ServingSize pgtype.Numeric
	ImagePath   pgtype.Text
	ID          pgtype.UUID
}

// all fields are optional except for id
func (q *Queries) UpdateRecipe(ctx context.Context, arg UpdateRecipeParams) error {
	_, err := q.db.Exec(ctx, updateRecipe,
		arg.CreatorID,
		arg.DateCreated,
		arg.Name,
		arg.Description,
		arg.Steps,
		arg.Allergens,
		arg.CookingTime,
		arg.ServingSize,
		arg.ImagePath,
		arg.ID,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE Users
SET
  email = COALESCE($1, email),
  name = COALESCE($2, name),
  date_joined = COALESCE($3, date_joined),
  pref_measure = COALESCE($4::measure_type, pref_measure)
WHERE 
  id = $5
RETURNING id, email, name, date_joined, pref_measure
`

type UpdateUserParams struct {
	Email       pgtype.Text
	Name        pgtype.Text
	DateJoined  pgtype.Date
	PrefMeasure NullMeasureType
	ID          pgtype.UUID
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.Email,
		arg.Name,
		arg.DateJoined,
		arg.PrefMeasure,
		arg.ID,
	)
	return err
}
